---
title: "Deep Dive: Implementasi Concurrency di Rust, Go, dan Java - Apa yang Engineer Perlu Tahu?"
description: "Analisis mendalam perbandingan pattern concurrency di Rust, Go, dan Java melalui studi kasus perhitungan bilangan prima paralel, dengan insights praktis untuk software engineers."
date: "February 2025"
readTime: "15 min read"
category: "Technology"
emoji: "🔥"
slug: "deep-dive-concurrency-rust-go-java"
keywords:
  [
    "Concurrent Programming",
    "Rust Threading",
    "Go Goroutines",
    "Java ExecutorService",
    "Performance Analysis",
    "Parallel Computing",
    "Software Engineering",
    "Technical Deep Dive",
  ]
---

Sebagai software engineer, kita sering dihadapkan dengan pilihan teknologi untuk menangani komputasi paralel. Bagaimana kita memilih antara **Rust** dengan zero-cost abstractions-nya, **Go** dengan goroutines yang ringan, atau **Java** dengan eksosistem mature-nya?

Artikel ini akan membedah implementasi concurrency di ketiga bahasa tersebut melalui studi kasus real: **parallel prime number calculation**. Kita akan melihat tidak hanya performa, tapi juga pattern, idiom, dan best practices di masing-masing bahasa.

## 🎯 The Challenge: Parallel Prime Calculation

Kita akan menghitung bilangan prima hingga 10 juta menggunakan 8 thread parallel. Problem ini dipilih karena:

- CPU-bound task yang ideal untuk parallel processing
- Mudah dibagi menjadi independent chunks (embarrassingly parallel)
- Membutuhkan koordinasi untuk result aggregation
- Hasil yang deterministik untuk verifikasi
- Ideal untuk benchmarking yang fair

## 💡 Deep Dive: Pattern dan Implementasi

### 1. Go Implementation: Goroutines & Channels

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func isPrime(n uint64) bool {
    if n <= 1 { return false }
    if n <= 3 { return true }
    if n%2 == 0 || n%3 == 0 { return false }
    for i := uint64(5); i*i <= n; i += 6 {
        if n%i == 0 || n%(i+2) == 0 {
            return false
        }
    }
    return true
}

func countPrimes(iterations int) {
    target := uint64(10_000_000)  // 10 million
    threads := 8
    chunkSize := target / uint64(threads)

    var totalDuration int64

    for iter := 0; iter < iterations; iter++ {
        start := time.Now()
        var wg sync.WaitGroup
        countChan := make(chan int, threads)

        // Spawn goroutines for each chunk
        for i := 0; i < threads; i++ {
            wg.Add(1)
            go func(start, end uint64) {
                defer wg.Done()
                count := 0
                for n := start; n <= end; n++ {
                    if isPrime(n) {
                        count++
                    }
                }
                countChan <- count
            }(uint64(i)*chunkSize+1, uint64(i+1)*chunkSize)
        }

        // Close channel after all goroutines complete
        go func() {
            wg.Wait()
            close(countChan)
        }()

        // Collect results
        totalPrimes := 0
        for count := range countChan {
            totalPrimes += count
        }

        duration := time.Since(start).Milliseconds()
        totalDuration += duration

        fmt.Printf("Iteration %d: Found %d primes up to %d in %dms\n",
                  iter+1, totalPrimes, target, duration)
    }

    fmt.Printf("\nLanguage: Go\n")
    fmt.Printf("Average time over %d iterations: %dms\n",
              iterations, totalDuration/int64(iterations))
}

func main() {
    // Warm-up run
    countPrimes(1)
    fmt.Printf("\nWarm-up complete. Starting benchmark...\n\n")
    // Actual benchmark
    countPrimes(5)
}
```

**🔍 Key Design Patterns:**

- Menggunakan `sync.WaitGroup` untuk sinkronisasi
- Buffered channel untuk result collection
- Goroutines yang ringan (bisa spawn ribuan)
- Multiple iterations untuk accurate benchmarking

**💪 Strengths:**

- Syntax yang clean dan intuitive
- Lightweight concurrency
- Built-in synchronization primitives
- Performa paling konsisten di antara ketiga bahasa

### 2. Java Implementation: ExecutorService & Futures

```java
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

public class Main {
    private static boolean isPrime(long n) {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 == 0 || n % 3 == 0) return false;
        for (long i = 5; i * i <= n; i += 6) {
            if (n % i == 0 || n % (i + 2) == 0) return false;
        }
        return true;
    }

    static class PrimeCounter implements Callable<Integer> {
        private final long start;
        private final long end;

        PrimeCounter(long start, long end) {
            this.start = start;
            this.end = end;
        }

        @Override
        public Integer call() {
            int count = 0;
            for (long n = start; n <= end; n++) {
                if (isPrime(n)) count++;
            }
            return count;
        }
    }

    private static void countPrimes(int iterations) throws InterruptedException, ExecutionException {
        long target = 10_000_000;  // 10 million
        int threads = 8;
        long chunkSize = target / threads;
        long totalDuration = 0;

        for (int iter = 0; iter < iterations; iter++) {
            // Create thread pool
            ExecutorService executor = Executors.newFixedThreadPool(threads);
            List<Future<Integer>> futures = new ArrayList<>();

            long startTime = System.currentTimeMillis();

            // Submit tasks
            for (int i = 0; i < threads; i++) {
                long start = i * chunkSize + 1;
                long end = (i == threads - 1) ? target : (i + 1) * chunkSize;
                futures.add(executor.submit(new PrimeCounter(start, end)));
            }

            // Collect results
            int totalPrimes = 0;
            for (Future<Integer> future : futures) {
                totalPrimes += future.get();
            }

            long duration = System.currentTimeMillis() - startTime;
            totalDuration += duration;

            System.out.printf("Iteration %d: Found %d primes up to %d in %dms%n",
                            iter + 1, totalPrimes, target, duration);

            executor.shutdown();
            executor.awaitTermination(10, TimeUnit.SECONDS);
        }

        System.out.println("\nLanguage: Java");
        System.out.printf("Average time over %d iterations: %dms%n",
                         iterations, totalDuration / iterations);
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        // Warm-up run
        countPrimes(1);
        System.out.println("\nWarm-up complete. Starting benchmark...\n");
        // Actual benchmark
        countPrimes(5);
    }
}
```

**🔍 Key Design Patterns:**

- Thread pool management dengan ExecutorService
- Task definition menggunakan Callable
- Future untuk async result handling
- Proper resource cleanup dengan shutdown

### 3. Rust Implementation: Native Threads & Ownership

```rust
use std::time::Instant;
use std::thread;

fn is_prime(n: u64) -> bool {
    if n <= 1 { return false; }
    if n <= 3 { return true; }
    if n % 2 == 0 || n % 3 == 0 { return false; }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 { return false; }
        i += 6;
    }
    true
}

fn count_primes(iterations: u32) {
    let target = 10_000_000;  // 10 million
    let threads = 8;
    let chunk_size = target / threads as u64;

    let mut total_duration = 0;

    for iter in 0..iterations {
        let start = Instant::now();
        let mut handles = vec![];

        // Spawn threads
        for i in 0..threads {
            let start_num = i as u64 * chunk_size + 1;
            let end_num = if i == threads - 1 {
                target
            } else {
                (i as u64 + 1) * chunk_size
            };

            handles.push(thread::spawn(move || {
                (start_num..=end_num)
                    .filter(|&n| is_prime(n))
                    .count()
            }));
        }

        // Collect results
        let mut prime_count = 0;
        for handle in handles {
            prime_count += handle.join().unwrap();
        }

        let duration = start.elapsed().as_millis();
        total_duration += duration;

        println!("Iteration {}: Found {} primes up to {} in {}ms",
                iter + 1, prime_count, target, duration);
    }

    println!("\nLanguage: Rust");
    println!("Average time over {} iterations: {}ms",
             iterations, total_duration / iterations as u128);
}

fn main() {
    // Warm-up run
    count_primes(1);
    println!("\nWarm-up complete. Starting benchmark...\n");
    // Actual benchmark
    count_primes(5);
}
```

## 📊 Benchmark Results (5 iterations)

```
Language: Go
Warm-up: 1666ms
Iterations: 1902ms, 1919ms, 1984ms, 1997ms, 1899ms
Average: 1940ms

Language: Java
Warm-up: 1908ms
Iterations: 1868ms, 1875ms, 1718ms, 1892ms, 1891ms
Average: 1848ms

Language: Rust
Warm-up: 2368ms
Iterations: 2342ms, 2394ms, 2360ms, 2312ms, 2341ms
Average: 2349ms
```

## 🎯 Key Insights untuk Software Engineers

### 1. Performance Analysis

- **Java (1848ms)**:

  - Performa terbaik dalam test ini
  - JIT optimization bekerja sangat efektif
  - Thread pool management yang matang
  - Konsistensi yang baik antar iterasi

- **Go (1940ms)**:

  - Performa kompetitif dengan Java
  - Variasi performa yang wajar
  - Overhead scheduling tetap minimal
  - Memory management yang efisien

- **Rust (2349ms)**:
  - Trade-off antara safety dan performance terlihat
  - Konsistensi performa yang sangat baik
  - Memory safety tanpa GC memiliki overhead
  - Hasil masih kompetitif untuk use-case ini

### 2. Implementation Complexity

1. **Go**:

   - Paling straightforward untuk diimplementasi
   - Pattern yang clean dan mudah dipahami
   - Error handling bisa tricky untuk concurrent code

2. **Java**:

   - Boilerplate lebih banyak tapi structured
   - Exception handling lebih robust
   - Thread management lebih explicit

3. **Rust**:
   - Learning curve paling tinggi
   - Ownership system memerlukan pemahaman mendalam
   - Safety guarantees di compile time

## 🎯 Rekomendasi Praktis

1. **Untuk Microservices & Cloud Applications:**

   - Go adalah pilihan optimal
   - Performa konsisten dan resource usage efisien
   - Cocok untuk scalable services

2. **Untuk Enterprise Applications:**

   - Java masih sangat relevan
   - Ecosystem mature dengan tooling lengkap
   - Performance gap dengan Go minimal

3. **Untuk Systems Programming:**
   - Rust tetap pilihan solid
   - Memory safety tanpa GC
   - Ideal untuk performance-critical systems

## 📚 Resources untuk Further Learning

- [Go Concurrency Patterns](https://go.dev/blog/pipelines)
- [Java Concurrency in Practice](https://jcip.net/)
- [Rust Async Book](https://rust-lang.async.rs/)
- [Effective Go](https://golang.org/doc/effective_go)

## 🎯 Kesimpulan

Hasil benchmark menunjukkan bahwa ketiga bahasa memiliki kapabilitas concurrency yang mature dengan trade-offs masing-masing:

1. Go unggul dalam simplicitas dan performa
2. Java kompetitif dengan tooling mature
3. Rust menawarkan safety guarantees dengan trade-off di complexity

Pemilihan teknologi harus didasarkan pada:

- Use case spesifik
- Team expertise
- Production requirements
- Maintenance considerations

Yang penting bukan hanya raw performance, tapi juga maintainability, reliability, dan developer productivity dalam jangka panjang.
